/*
    http://www.mrobot.by
    http://www.maxxlife.by
    http://www.vk.com/cookrobot
    Copyright (c) Кухня роботов <maxxlife.by> All rights reserved.
    Copyright (c) Макслайф Робот Maxxlife Robot All rights reserved.


    Наши лаборатории по робототехнике:
    Ленинская РОС ДОСААФ, ул. Рокоссовского 63/2, Минск, Беларусь
    Подробнее в нашей группе Вконтакте http://www.vk.com/cookrobot
    И на сайте http://www.maxxlife.by

    ****************************************************
    Мы всегда рады новым членам нашего сообщества Кухня Роботов.
    У нас есть бесплатные вводные курсы, где мы объясняем
    как работать с нашими образовательными наборами по робототехнике и электронике.
    ****************************************************

    Название набора: Набор Роботов А1
    Описание схемы: Схема 11 Игра “Кнопочные гонки”

    Программа создана и протестирована разработчиком:
    Имя: Максим Массальский
    Ник: maxxlife
    E-mail: maxxliferobot@gmail.com
    Дата разработки: 14.08.2015
*/

//Переменная с номером цифрового пина внешнего светодиода первого игрока
int led_pin_one = 5;
volatile int value_one = 0;


//Переменная с номером цифрового пина внешнего светодиода второго игрока
int led_pin_two = 6;
volatile int value_two = 0;

//Переменная с номером цифрового пина сигнального светодиода
int led_start = 4;

// Переменные, отвечающие за случаный старт программы.
// Чтобы сигнальный светодиод выключался неожиданно.

// В данной переменной типа bool может хранится 1 либо 0. 
// Это своеобразный индикатор состояния программы.
bool state = 1;
// В этой переменной хранится время задержки, которое будет случайно сгенерировано
int random_delay = 0;

// Функция по подсчету количества нажатий на кнопку первого игрока
void player_one()
{
  // Прибавляем к переменной value_one число 10
  // Запись value_one+=10 равносильна записи value_one=value_one+10;
  value_one += 10;

  //Выводим в монитор порта строку
  Serial.print("Player one: ");
  Serial.println(value_one);

  // Задержка в 50мс для устранения дребезга кнопки и ее ложного срабатывания.
  delay(50);

}

// Функция по подсчету количества нажатий на кнопку второго игрока
// Функция player_two идентична функции player_one
// за исключением переменной количества подсчета нажатий
void player_two()
{
  value_two += 10;
  //Выводим в монитор порта строку
  Serial.print("Player two: ");
  Serial.println(value_two);
  delay(50);
}
// Функция по морганию светодиодом первого игрока,
// В случае его выигрыша
void blink_led_one()
{
  for (int i = 0; i < 4; i++)
  {
    digitalWrite(led_pin_one, HIGH);
    delay(200);
    digitalWrite(led_pin_one, LOW);
    delay(200);
  }
}

// Функция по морганию светодиодом второго игрока,
// В случае его выигрыша
void blink_led_two()
{
  for (int i = 0; i < 4; i++)
  {
    digitalWrite(led_pin_two, HIGH);
    delay(200);
    digitalWrite(led_pin_two, LOW);
    delay(200);
  }
}

// Функция по морганию светодиодом двух игроков,
// Если количество нажатий поровну, ничья
void blink_led_one_two()
{
  for (int i = 0; i < 4; i++)
  {
    digitalWrite(led_pin_one, HIGH);
    digitalWrite(led_pin_two, HIGH);
    delay(200);
    digitalWrite(led_pin_one, LOW);
    digitalWrite(led_pin_two, LOW);
    delay(200);
  }
}
void setup()
{
// Данная строка говорит нам о том, что цифровые выводы настроены на выход
// Для удобства работы цифра с номером вывода занесена в переменную
  pinMode(led_pin_one, OUTPUT);
  pinMode(led_pin_two, OUTPUT);
  pinMode(led_start, OUTPUT);
  
// Инициализация прерываний на цифровые порты 2, 3
// Когда на этих выводах значение напряжения изменится с LOW на HIGH (кнопка замкнет цепь)
// То будут вызваны функции подсчета количества нажатий на кнопку.
// Прерывания обрабатываются параллельно основной программе в void loop ()
  attachInterrupt(2, player_one, RISING);
  attachInterrupt(3, player_two, RISING);
  
// Удаление небольшо бага связанного с обработкой прерываний
  digitalWrite(2, LOW);
  digitalWrite(2, HIGH);
  digitalWrite(2, LOW);
// Зажержка в 100мс.
  delay(100);
  
// Данная строка означает инициализацию последовательного порта на скорости 9600 бод
  Serial.begin(9600);
}


void loop()
{
  // Цикл if отвечает за старт программы и моргание красным, сигнальным светодиодом
  if (state == 1)
  {
    // Тушим светодиоды игроков перед новой "гонкой"
    // Записывая значения 0 в функции analogWrite
    analogWrite(led_pin_two, 0);
    analogWrite(led_pin_one, 0);
    
// Генерируем случайную задержку в диапазоне от 0.5 секунд до 3-х секунд
    random_delay = random(500, 3000);
    // Зажигаем красный светодиод
    digitalWrite(led_start, HIGH);
// Создаем случайную задержку
    delay(random_delay);
// Выключаем светодиод
    digitalWrite(led_start, LOW);
    // Обнуляем все переменные, чтобы попасть в else, при следующем цикле программы
    state = 0;
    value_one = 0;
    value_two = 0;
  }
  else
  {

// Зажигаем светодиоды игроков в зависимости от набраных ими очков
    analogWrite(led_pin_two, value_two);
    analogWrite(led_pin_one, value_one);
// Как только очки одного из игроков превысят 255,
// Начнет выполнятся один из циклов if в зависимости от того,
// кто набрал большее количество очков.

// Если набрал больше очков первый игрок
    if (value_one >= 255)
    {
      // Обнуление очков второго игрока
      value_two = 0;
      // Выводим надпись на экран
      Serial.println("Player One WON!");
      // Вызываем функцию по морганию светодиодом первого игрока-победителя
      blink_led_one();
      // Обнуление очков первого игрока
      value_one = 0;
      // Переменной state присваиваем значение 1, чтобы можно было зайти в главный цикл if,
      // И начать игру заново с сигнального, красного светодиода
      state = 1;
    }
// Если набрал больше очков второй игрок
    if (value_two >= 255)
    {
      value_one = 0;
      Serial.println("Player Two WON!");
      blink_led_two();
      value_two = 0;
      state = 1;
    }
// Если количество очков было набрано поровну и больше 255
    if ((value_one >= 255) && (value_two >= 255))
    {
      Serial.println("DRAW!");
      blink_led_one_two();
      value_one = 0;
      value_two = 0;
      state = 1;
    }
  }
}
